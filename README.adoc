= CloudSim Plus: A Modern Java 8 Framework for Modeling and Simulation of Cloud Computing Infrastructures and Services
Manoel C. Silva_Filho <http://twitter.com/manoelcampos>; Raysa L. Oliveira <https://twitter.com/raysaloliveira>; Claudio C. Monteiro; Pedro_R. M. Inácio; Mário M. Freire.
:homepage: http://cloudsimplus.org
:source-highlighter: coderay
:imagesdir: images
:src: ../../projects/cloudsim-plus
:toc:

image::https://licensebuttons.net/l/by-sa/4.0/88x31.png[]
This work is licensed under a http://creativecommons.org/licenses/by-sa/4.0/[Creative Commons Attribution-ShareAlike 4.0 International License].

== Introduction
Cloud Computing is an important technology that has leveraged innovation in different knowledge fields and economic sectors by providing distributed, scalable, manageable and fault-tolerant computing resources over the Internet. The large adoption of Cloud computing services can be also explained by diverse reasons such as its pay-per-use charging model that enables cost reduction for customers, the rapid and automated allocation of resources that enable applications to quickly respond to bursts, and full-featured web and console interfaces that enable customers to configure hosted services easily.

The advances brought by Cloud Computing are backup up by academy and industry research and have increasingly attracted new researchers. There are different issues to be addressed that makes Cloud to be an active research field, including SLA fulfillment, optimal VM placement and migration, cost reduction, power efficiency, hotspot detection, load balance, fault tolerance, anomalies detection, security enforcement, traffic and latency reduction and so on.

Considering the complexity of a Cloud infrastructure and the need to model proposed solutions and evaluate them in a quick, cheap and repeatable way, using a controlled environment that makes it easy to monitor and collect metrics, computer-based simulation is largely used to carry out research in this field.

Accordingly, in this article we present CloudSim Plus, a new, full-featured, re-designed, highly extensible and modern Java 8 framework to enable modeling and simulation of Cloud Computing infrastructure, services, underlying mechanisms and algorithms. CloudSim Plus enable researchers to model and simulate different Cloud scenarios, by implementing them using Java. Such scenarios can be used to experiment existing and potential solutions for the issues mentioned above. 

CloudSim Plus is an open source project available at http://cloudsimplus.org and http://cloudsimplus.org/docs/maven.html[Maven Central].

== Overview
CloudSim Plus is a simulation framework based on CloudSim 3, that went through an extensive re-design and re-engineering process to provide an updated, modern, more accurate, highly extensible, easier-to-use and state-of-the-art framework aiming sustainable maintainability for long-term evolution. To achieve such goals, CloudSim Plus is founded on several software design and engineering metrics, principles and practices such as https://en.wikipedia.org/wiki/Coupling_(computer_programming)[Coupling], https://en.wikipedia.org/wiki/Cohesion_(computer_science)[Cohesion], https://en.wikipedia.org/wiki/Software_design_pattern[Design Patterns], https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)[SOLID principles] and other ones like https://pt.wikipedia.org/wiki/Don't_repeat_yourself[Don't Repeat Yourself (DRY)] and https://en.wikipedia.org/wiki/KISS_principle[KISS].

== Philosophy and Motivation
https://en.wikipedia.org/wiki/Software_quality[Software quality] has increasingly become essential for software industry, as can be seen by the number of current software design and development methodologies and processes such as https://en.wikipedia.org/wiki/Domain-driven_design[Domain-Driven Design (DDD)], https://en.wikipedia.org/wiki/Test-driven_development[Test-Driven Development (TDD)], https://en.wikipedia.org/wiki/Behavior-driven_development[Behavior-Driven Development (BDD)], Clean Code Programming and many more. Different tools have been used to collect and monitor software quality metrics to try detecting issues as soon as possible, such as https://en.wikipedia.org/wiki/Static_program_analysis[Static Code Analysis] and https://en.wikipedia.org/wiki/Integration_testing[Integration Testing] in an automated https://en.wikipedia.org/wiki/Continuous_integration[Continuous Integration] environment.

We understand that the same software quality pursued by the software industry must as well be pursued by academic projects to reduce https://en.wikipedia.org/wiki/Technical_debt[technical debt] and avoid https://en.wikipedia.org/wiki/Software_rot[software erosion], delivering industry-standard quality products.

We are strong adepts of open source philosophy and we started by effectively contributing to CloudSim in 2015. However, since CloudSim is not highly compliant with these software design and engineering principles, practices and philosophies and our team has different views of how the framework should evolve, we decided to start CloudSim Plus as an independent fork. We also believe that source code needs to be curated, without meaning it will restrict contributions, as it is successfully proved by important projects like the https://github.com/torvalds/linux[Linux Kernel].

Finally, enforcement of backward compatibility is a common concern in software development, mainly for public APIs such as those ones provided by a framework. However, such a concern slows down software evolution and we contrary understand that a cloud simulation framework is predominantly used for research purposes, even by industry. Cloud simulation scenarios are tightly coupled to a specific version of the simulation framework and after they produces the final results and the research goes on, new scenarios can be built using an updated version of the framework, without worrying about the older scenario. Accordingly, we are not afraid of breaking compatibility so that we can foster project advances.

== Architecture
CloudSim Plus is a Java Maven project that has a simpler and better module and package structures. The entire project is compounded of 4 modules that were re-organized to directly inherit from the parent project, allowing a researcher to quickly have an overview of the structure. Redundant and out-of-date modules such as "distribution" and "documentation" were removed since building distribution artifacts and documentation is already automated using Maven.

The figure below presents the current project architecture and its modules are described as follows. The highlighted modules are new in CloudSim Plus.

image::modules.png[title="CloudSim Plus Modules", scaledwidth="70%"]

=== Modules
CloudSim Plus API is the main module that contains the framework API. It is the only independent module that is required to build simulation scenarios. Since such a module is available at http://cloudsimplus.org/docs/maven.html[Maven Central], there is no need to manually download the source code to build simulations using the framework. This module can just be http://cloudsimplus.org#maven[added as a maven dependency to your own project] and you are ready to start building your simulation scenarios.

CloudSim Plus Examples provides the original CloudSim examples, with refactored, better organized code and updated to use the CloudSim Plus API. It also includes new examples for CloudSim Plus exclusive features. 

CloudSim Plus Testbeds modules provides some classes that implement simulation testbeds in a repeatable manner, allowing a researcher to collect valid scientific results, such as means and standard deviations, considering a specific confidence interval. They serve as examples on how to create broader testbed experiments.

CloudSim Plus Benchmarks module is used just internally to measure the overhead of some CloudSim Plus features. The interfaces are organized, from top to bottom, in the order required to create the objects that will represent the simulation scenario, including infrastructure, virtual machines and applications.

=== Package Structure
CloudSim Plus has a re-designed package organization, which ensures better https://en.wikipedia.org/wiki/Separation_of_concerns:[separation of concerns] and make it easier to understand the project structure and to locate some class to use, extend or simply to analyse its source code and/or documentation. Packages with a strong color contain exclusive CloudSim Plus classes and interfaces, while the lightly colored ones were introduced to improve organization but usually just contain classes and interfaces from CloudSim. The white packages already existed in CloudSim.

image::package-structure-reduced-cloudforum.png[title="CloudSim Plus Simplified Package Diagram", scaledwidth="70%"]

CloudSim Plus also introduce documentation for every package, quickly explaining the goals of containing classes and interfaces, as well as the main class inside the package. Such a documentation is an excellent start point for researchers to get an overview of the framework.

[[sec:how-cloudsim-plus-works,How CloudSim Plus Works]]
=== How CloudSim Plus Works
Creating a cloud simulation using CloudSim Plus requires one to write a Java program to model the simulation scenario. The simplified diagram below presents the main interfaces involved in creating such scenarios. For every presented interface, there is one or more implementing classes that have to be actually instantiated.
[[fig:class-diagram,Class Diagram]]
image::reduced-main-classes-cloudforum.png[title="CloudSim Plus Simplified Class Diagram", scaledwidth="70%"]

The process of building a simulation scenario is described below. To see more details on how to use CloudSim Plus, please check the http://cloudsimplus.org/#how-to-use-cloudsim-plus:[How to use CloudSim Plus] section at the official website. A http://cloudsimplus.org/#a-minimal-and-complete-simulation-example:[minimal and complete simulation example] is available there too. 

The `CloudSim` class is the first one that needs to be instantiated to start building a cloud simulation. CloudSim Plus just requires it to be instantiated using the default, no-arguments constructor, to initialize the simulation. The next steps are described as follows.

==== Datacenter
Instances of a `Datacenter` should be created that will represent the different data centers that compound the cloud infrastructure. Each `Datacenter` has a set of characteristics (such as its timezone and costs for charging customers) defined by a `DatacenterCharacteristics` object. It also must have a VmAllocationPolicy that defines the policy used to select a Host to place or migrate VMs.

For each Datacenter, a set of Hosts must be created, that represent the physical machines with actual computing power. Each Host must have a `VmScheduler` that defines the scheduling algorithm used by the Host to execute its VMs, existing 2 schedulers available. The `VmSchedulerTimeShared` enables executing VMs inside a Host in a preemptive, time-shared way, allowing different VMs to share CPU time when there are less CPUs than required by all VMs. The `VmSchedulerSpaceShared` is a non-preemptive scheduler that allocates physical CPUs to be exclusively used by each VM. If the current VMs require more CPUs than there are available, some VMs will not be allowed to be created.

For each Host, `ResourceProvisioners` objects must be set. They define the policy used by a Host to check whether is an specific amount of resource available for a requesting VM and to allocate that resource for such the VM is created. A `ResourceProvisioner` must be defined to manage the allocation of RAM, bandwidth and CPU (Processor Element, `Pe`) from the Host to virtual machines.

==== DatacenterBroker 
A Datacenter Broker is a software that receives requests from a cloud customer and is in charge to take required actions on behalf of the customer to attend such requests. Such requests usually are the creation and destruction of VMs and allocation of applications (called Cloudlets) inside some VM. The broker is accountable for some decision making, such as selecting a Datacenter and then a Host inside it to place each VM and mapping each Cloudlet to one of the available Vms. The instantiation of `DatacenterBrokers` is the next step, before creating and submitting VMs and Cloudlets to the cloud infrastructure.

The `DatacenterBrokerSimple` class always selects the first Datacenter to place submitted Vms, before trying other `Datacenters` when the allocation of a Vm fails in such a Datacenter. It provides a https://en.wikipedia.org/wiki/Round-robin_scheduling:[Round-robin] policy to select a Vm to run each Cloudlet, without assessing Cloudlet requirements or provider and customer goals.

CloudSim Plus enable the `DatacenterBrokerSimple` enabling that such behaviors to be changed in runtime, allowing a researcher to define the policies to place Vms and map Cloudlets to Vms, according to desired goals, without requiring the creation of a new `DatacenterBroker`. More details are discussed in the next section. 

==== Vm
A `Vm` is a Virtual Machine that belongs to a specific cloud customer, that a `DatacenterBroker` acts on behalf of. It abstractly represents a Virtual Machine in terms of RAM, CPU, Storage and Bandwidth requirements. For each Vm, a `CloudletScheduler` must be set to define the scheduling policy to be used to run the applications inside the `Vm`. Beyond time- and space-shared schedulers, that work as the VmSchedulers used by Hosts, CloudSim Plus provides a implementation of the https://en.wikipedia.org/wiki/Completely_Fair_Scheduler:[Completely Fair Scheduler] used in recent Linux Kernels.

Vms must be created and submitted to the broker that will decide in which Datacenter and Host each Vm will be placed. When a Vm is submitted, try broker tries request a selected Datacenter to create the VM. If the Datacenter does not have a Host with enough capacity for a Vm, the broker then forwards the request to other `Datacenters`, until the Vm is created or all `Datacenters` are requested. 

==== Cloudlet 
A `Cloudlet` abstractly represents an application running inside a Vm. Cloudlets and its related interfaces such as the `UtilizationModel` are used to define application models. A Cloudlet must define some resource requirements in advance, currently only CPU and storage. Such requirements can be used by a broker to decide how to map Cloudlets to VMs in order to attend such requirements and achieve provider and customer goals. 

`UtilizationModels` define how different `Vm` resources will be used by a Cloudlet along the time, namely RAM, CPU and Bandwidth resources. Implementations such as the `UtilizationModelStochastic` allows defining resource usage in a random way, using some pseudo random number generator (PRNG). CloudSim Plus enables a researcher to define the PRNG implementation to use, following a statistical distribution that attends his/her goals.

Cloudlet resource utilization can also be defined using the `UtilizationModelPlanetLab` class, based on a trace file from https://www.planet-lab.org:[Planet Lab Datacenters]. On the other hand, the `WorkloadFileReader` class enables the creation of an entire set of `Cloudlets` based on different Datacenter traces file formats. Currently only the http://www.cs.huji.ac.il/labs/parallel/workload/:[Standard Workload Format] from
http://new.huji.ac.il/en:[The Hebrew University of Jerusalem] is implemented.

== Exclusive Characteristics and Features
CloudSim Plus is a full-featured simulation framework which has introduced long-waited and exclusive features, that are presented below. It is also included discussions about how such features can be used. 

=== Dynamic creation of VMs and Applications (Cloudlets)
CloudSim Plus allows on-demand creation of VMs and Cloudlets, without requiring creation of Datacenter Brokers at runtime. The `DatacenterBroker` class was updated enable submission of new VMs and Cloudlets during simulation execution and accordingly request the creation of such objects into the Cloud infrastructure. It also enables delaying the creation of submitted Cloudlets for simulation of dynamic arrival of tasks.

=== VM Scaling
VM migration is a well-known mechanism used to optimize allocation of physical resources, that can be applied for different goals such as reduction of costs, energy consumption and resource wastage by consolidating multiple VMs into the same Host, reduction of network traffic by placing inter-communication VMs as close as possible, reduction of SLA violations by ensuring that the required resources will be available for hosted VMs, etc. It is a fundamental mechanism to provide the so called elasticity, that enables resources to be on-demand allocated or released.

However, VM migration is an expensive operation that causes service downtime, introduces overhead and must be performed carefully. Sometimes VM migrations can be avoided by simply scaling under or overloaded VMs. CloudSim Plus provides vertical and horizontal VM scaling mechanisms. 

These two different kinds of VM scaling, additionally with well-known VM migration algorithms, can be used selectively by a https://en.wikipedia.org/wiki/Hypervisor:[Hypervisor] to provide a very efficient VM allocation policy mechanism to define when it is time to vertically scale, horizontally scale or migrate a VM. Depending on specific conditions, one action can be favored over other ones or even different actions can be performed at a given time. CloudSim Plus VM Scaling mechanisms are discussed below.

==== Vertical VM Scaling
Vertical VM Scaling performs on-demand down or up allocation of VM resources such as Ram, Bandwidth and CPUs, according to under or overloaded VM condition, respectively. Since current hypervisors such as http://www.linux-kvm.org/page/Projects/auto-ballooning:[KVM] and VMware ESX allows dynamically changing allocation of https://labs.vmware.com/vmtj/memory-overcommitment-in-the-esx-server:[RAM] and https://pubs.vmware.com/vsphere-4-esx-vcenter/index.jsp?topic=/com.vmware.vsphere.vmadmin.doc_41/vsp_vm_guide/configuring_virtual_machines/t_change_cpu_hotplug_settings.html:[CPU] for a VM, that can be used to avoid VM migration in specific conditions.

Bandwidth scaling is simpler to be performed since it is a more abstract resource, different from virtualized RAM and CPU that are linked to the physical corresponding resource from a physical machine. By this way, such a scaling can be easily performed in routers and CloudSim Plus simulate such a scaling mechanism.

Using Vertical VM Scaling feature it is possible to accommodate rising demand of applications running inside a VM, without migrating the VM or creating another ones. Such a CloudSim Plus feature enables performing simulations to assess, for instance, what is the workload limit that a VM supports, for a given application model, before requiring the creation of new VMs to balance the load, that is discussed in the next sub-section. 

==== Horizontal VM Scaling
Horizontal VM Scaling allows the dynamic destruction or creation of VMs, according to an under or overload condition, respectively. Such conditions are defined by a https://en.wikipedia.org/wiki/Predicate_(mathematical_logic):[predicate] that can check different VM resources usage such as CPU, RAM or Bandwidth, to define if a VM is under or overloaded.

Depending on the model of an application running inside a VM, by just performing a vertical up scaling when the VM is overloaded may not be enough to support the demand. Consider a web application relying on a Database Management Systems (DBMS) and a Web/Application Server. Often, it is required to create new VMs running separate instances of a Web/Application Server to distribute user requests among them. It may be not enough just assigning more CPUs or RAM to a VM, in an attempt to enable more threads to process user requests. Usually a single process may have difficult to handle so many threads. 

Alternatively, Horizontal VM Scaling comes in handy by allowing cloning a VM to balance the load. This feature allows a researcher to implement and evaluate load balancing algorithms for dynamic workloads and burst conditions, by enabling the creation of new VMs to attend the demand. Some cloud platforms such as Amazon Web Services provide an https://aws.amazon.com/autoscaling/:[Auto Scaling] feature, that can be alike simulated in CloudSim Plus.

=== Parallel execution of simulations
Production of scientifically valid simulation results depends on several factors that include the accuracy of the simulator, https://en.wikipedia.org/wiki/Reproducibility:[experiments reproducibility] and collection of statistic metrics over several simulation runs. Although CloudSim Plus provides a lightweight, fast and easy way to model and run cloud simulation experiments, depending on the experiment scale it may take several minutes to run, mainly when the workload is created from real and large datacenter traces. Several runs of such experiments can take even hours to finish. 

CloudSim Plus was re-designed to enable running multiple experiments in parallel in a multi-core machine, to reduce the time spent in running simulations. Such a feature was enabled by changing all simulation state that was being managed in a static way, inside the `CloudSim` class, to be managed by instances of such a class. The benefits of this approach are two-fold: to initialize the simulation, one has just to instantiate a `CloudSim` object, instead of calling a start method with lots of redundant parameters; each `CloudSim` instance owns all the objects that belongs to the simulation it manages, allowing that each simulation run independently in an isolated-way.

The real reduction that can be got by running simulations in parallel is tightly dependent of the simulation scenario and scale. If the simulation is CPU-bound and is compound of several runs, then the parallelization will provide great time reduction. On the other hand, small scale simulations or I/O-bound ones may not take advantage of this feature.

The https://github.com/manoelcampos/cloudsim-plus/blob/master/cloudsim-plus-examples/src/main/java/org/cloudsimplus/examples/ParallelSimulationsExample.java:[example available here] shows how it is simple and straightforward to parallelize simulation experiments in CloudSim Plus using the http://www.oracle.com/technetwork/articles/java/ma14-java-se-8-streams-2177646.html:[Java 8 Stream API]. Consider there is a class called `ParallelSimulationsExample` that represents a simulation scenario and contains a method `run` to build and start a simulation, and then a List of instances of such a scenario with possible different configurations and/or generating random data using different seeds. Running each scenario instance is as simple as calling the single line of code below:

[source,java]
----
include::{src}/cloudsim-plus-examples/src/main/java/org/cloudsimplus/examples/ParallelSimulationsExample.java[tags="parallelExecution",indent=0]
----

Since `CloudSim` class was re-designed, it enables using the https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html:[Parallel Streams] feature of Java 8, which makes straightforward to execute simulations in parallel.

=== Listeners

One of the features that must be provided by a cloud infrastructure is the ability to monitor running services. Monitoring capabilities can be use by different parties. The cloud provider can collect resource utilization to charge customers in a pay-per-use basis, to assess fulfillment of customer SLA or to optimize resource allocation to avoid under and over provisioning in order to reduce costs and energy consumption. Customers can use such monitoring features to assess if the kind of resources he/she has contracted is appropriated to its demand and then take the required actions they aren't. 

Despite the usage of cloud resources is charged in a pay-per-use basis, it is up to the customer to correctly configure the services he/she is using in order to ensure that expected quality of service he/she wants to provide for his/her final users is being achieved. Scaling mechanisms that provide the so called elasticity commonly must be enabled and configured by the customer, otherwise resources will not be scaled, for instance, to attend bursts. 

Accordingly, CloudSim Plus provides Listeners as a mechanism to monitor simulation in runtime, allowing collection of metrics, resource allocation decision making (such as VM scaling) and granular simulation execution feedback. Since the final goal of a simulation is the collection of data to be processed, assessed and validated, Listeners enable researchers to collect such data in any time interval they want and writing it in any desired portable format such as CSV, JSon, XML, YML or any other.

Despite CloudSim Plus is far easier to use and provides several new useful features, understanding and correctly implementing large scale simulation scenarios can be a hard task. Listeners can be used by researchers to follow up simulation execution and to collect data for debug purposes.

The Listeners are an implementation of the https://en.wikipedia.org/wiki/Observer_pattern:[Observer Design Pattern] and were implemented using the https://www.oreilly.com/learning/java-8-functional-interfaces:[Java 8 Functional Interfaces] that enable the use of Lambda Expressions to define the code that will capture some event, without requiring the use an anonymous classes for each event to be handled. This feature was designed to allow defining different handlers for the same event, enabling the use this feature internally by the framework itself as well as by the researcher building cloud simulations. Such Listeners are currently being used to implement Integration Tests to assess the accuracy of the simulation framework. Examples using some Listeners can be found https://github.com/manoelcampos/cloudsim-plus/tree/master/cloudsim-plus-examples/src/main/java/org/cloudsimplus/examples/listeners:[here]. Some available listeners are presented below, grouped by the class they belong to.

==== Host Listeners
Such Listeners enable getting notifications about events happening inside a Host. Currently only the `onUpdateProcessingListener` is defined, which enables receiving notifications when the execution progress of VMs inside the Host is updated. This Vm processing update is as if the Host operating system is allowing the execution of some more Vm CPU instructions, that will impact resource usage such as RAM, Bandwidth and obviously CPU too.

Using such a Listener, a researcher can monitor, for instance, if a specific Vm placement configuration is enabling a balanced resource usage, i.e., whether resources are begin used in similar proportions along VMs execution. An unbalanced resource usage situation sets a resource wastage scenario and prevents new VMs to be placed at the Host, due to the unavailability of some resources, while other ones are plenty.

==== Vm Listeners
Such Listeners enable getting notifications about events happening inside a Vm and are presented below.

- `onHostAllocationListener`: get notifications when a `Host` is allocated to a `Vm`, that is, when a `Vm` is placed inside some `Host`. Such a Listener can be used to log the different `Hosts` that a `Vm` is placed along its life cycle, since the `Vm` may be migrated to different `Hosts` when a `Host` becomes under or overloaded. It also enables to check in runtime if a specific `Vm` allocation policy is placing `Vms` at the expected `Hosts`. 
- `onHostDeallocationListener`: this is the opposite of the previous listener, being notified every time when a `Vm` is destroyed or moved from a `Host`. `Vms` must be created before applications (`Cloudlets`) are submitted to a broker. Sometimes applications finish running inside a `Vm` while it remains idle for long time periods, potentially avoid other `Vms` to be placed inside the `Host` because resources that could be used by new `Vms` are provisioned to this idle one. Using this Listener it is possible to determine the time difference when the `Vm` was destroyed and when it became idle. By this way, the broker policy that defines when `Vms` should be freed can be assessed to optimize resource allocation.
- `onUpdateProcessingListener`: get notifications when the execution progress of a `Vm` is updated. This event is fired by the event of same name from the `Host` where the `Vm` is placed. In the same way, it can be used, for instance: to log `Vm` resource usage along its execution, enabling detection of under and overload conditions; to determine if such resources are balanced; to detect and log SLA violations. Such a Listener is also used internally by the Horizontal and Vertical Vm Scaling mechanisms, presented above, to verify if a `Vm` is under or overloaded for performing down or up scaling, respectively.
- `onCreationFailureListener`: get notifications when a `Vm` fails to be placed into a selected `Datacenter`, due to lack of a `Host` with enough resources. This notification is fired by a `DatacenterBroker` which usually will try other available `Datacenters` to place the `Vm`. If there are too many `Vm` creation failures, the `Vm` placement policy implemented by the `DatacenterBroker` may be failing to select a proper `Datacenter` for a `Vm` of it may  be signal that the cloud infrastructure is not being able to attend the demand. In any case, this Listener enables logging such failures in order to take the required actions. It may be used, for instance: to assess the suitability of a specific `Vm` placement policy to reduce the time to attend a `Vm` placement request; or to study current cloud provider restrictions and expansion needs.

==== Cloudlet Listeners
Such Listeners enable getting notifications about events happening inside a `Cloudlet`.

- `onUpdateProcessingListener`: get notifications when the execution progress of a `Cloudlet` is updated. This event is fired by the event of same name from the `Vm` where the `Cloudlet` is running. It enables monitoring applications resource usage along execution time, for instance, to evaluate if such `Vm` applications are not contending the same resources. For instance, if a `Vm` has multiple CPU-bound `Cloudlets`, their execution performance may be affected, increasing response and task completion time. Such a condition may lead to SLA violations and reveals a flaw at the `DatacenterBroker` policy used to select a `Vm` to run each `Cloudlet`. 
- `onFinishListener`: get notifications when a `Cloudlet` finishes executing. Such a Listener can be used to collect different metrics such as wait, actual execution and completion time for each application. Such metrics and application requirements could be used, for instance, in a back propagation process to enable a `DatacenterBroker` to improve its `Cloudlet` to `Vm` mapping policy. This listener enables collecting metrics immediately after `Cloudlets` finish, without having to wait up to simulation end. By this way, using techniques such as machine learning, the learning phase can be adjusted at simulation runtime.

==== CloudSim Listeners
Listeners inside the `CloudSim` class are the most general ones available in CloudSim Plus, that may have a broader applicability. The current implemented Listeners are described below:

- `onClockTickListener`: get notifications when the simulation clock advances, enabling to perform any desired action at a given time. Since CloudSim Plus allows dynamic creation of `Cloudlets` and `Vms`, as presented before, such a Listener can be used to submit new instances of those objects to a `DatacenterBroker`, simulating the dynamic arrival of customers requests and workload generated by final users.
- `onSimulationPausedListener`: get notifications when the simulation is paused. Such a Listener can be used, for instance, to collect partial simulation data after the simulation is intentionally paused at a given time, ensuring that the simulation state will not change during data collection. 
- `onEventProcessingListener`: get notifications when any event is processed by CloudSim Plus. It is a more general Listener that provides the original data related to the happened event, that is totally dependent of the kind of event. Since CloudSim Plus is a discrete event simulation framework, any event that happens will be caught by such Listeners. Since it is the most generic Listener available, it may have several different uses. 

=== Strongly object-oriented framework
CloudSim Plus was comprehensive re-engineered to create relationships among classes, enabling chained calls such as `cloudlet.getVm().getHost().getDatacenter()`, instead of storing just integer IDs to represent the relationship among classes, which does not conform to an object-oriented design. As the presented <<fig:class-diagram>> shows, an object, such as a `Cloudlet`, defines relationships to keep a reference to each object it is related to. 

The line of code presented above provides a direct way to know what `Vm` a `Cloudlet` is running or will run, what `Host` such a `Vm` is placed into, and finally what `Datacenter` such a `Host` is settled down. The https://en.wikipedia.org/wiki/Null_Object_pattern:[Null Object Design Pattern] was also implemented to avoid the so propagated `NullPointerException` when making such a chained call.

=== Classes and interfaces to allow implementation of heuristics
Considering the large scale of cloud infrastructure, finding an optimal solution for issues such as Vm Placement is impracticable, since that is a NP-hard problem and thus an optimal solution cannot be found in polynomial time. Alternatively, http://en.wikipedia.org/wiki/Heuristic:[heuristic] techniques can be used to find a sub-optimal  and satisfactory solution in a reasonable time. 

Some well-know heuristic methods include
http://en.wikipedia.org/wiki/Tabu_search:[Tabu Search], http://en.wikipedia.org/wiki/Simulated_annealing:[Simulated Annealing] and http://en.wikipedia.org/wiki/Ant_colony_optimization_algorithms:[Ant Colony Systems]. These methods usually start with an initial random solution for a defined problem and iterative and randomly search other solutions. A fitness value to be maximized for each solution is computed by an utility function, then the solution finding stops when a desired fitness or number of iterations is reached. 

CloudSim Plus provides a set of classes and interfaces to enable a researcher to build such heuristics for solving problems such as Vm placement and migration. The interfaces provide a contract by defining methods signatures to implement the solution cost function (the fitness function is just the inverse of the cost), the solution generation function, number of maximum iterations, the probability for accepting each random solution and the predicate to define when the solution finding must stop. The package https://github.com/manoelcampos/cloudsim-plus/tree/master/cloudsim-plus/src/main/java/org/cloudsimplus/heuristics:[org.cloudsimplus.heuristics] contains such classes and interfaces and also includes a Simulated annealing heuristic to map a set of `Cloudlets` to a set of `Vms`.

=== Implementation of the Completely Fair Scheduler
Implementations of the `CloudletScheduler` interface, as presented in the Section <<sec:how-cloudsim-plus-works>>, define the algorithm used by a `Vm` to schedule the execution of its `Cloudlets`. One of the criticisms against simulation experiments is differences between some behaviors of the actual system begin simulated and the simulation itself, that may reduce the simulation accuracy. Process scheduling is one of the behaviors that was neglected in cloud computing simulations up to now. The scheduling algorithm impacts some application metrics such as wait time and task completion time. A bad scheduling may lead to tasks waiting for long time periods to use the CPU or, when it is assigned to a CPU, it is not given enough time slice to use it. That situation is called https://en.wikipedia.org/wiki/Starvation:[starvation] and may cause SLA violations. 

The https://en.wikipedia.org/wiki/Completely_Fair_Scheduler:[Completely Fair Scheduler] used in recent version of the Linux Kernel provide a very efficient policy to avoid the mentioned issues. As an actual scheduler, it considers assigned tasks priorities to define the time slice that each process is allowed to use the CPU at a time. It also try to be fair when allocating these time slices in order to avoid starvation of low priority processes. Accordingly, CloudSim Plus introduces a implementation of the Completely Fair Scheduler to increase the accuracy of processes execution in simulation environments. 

The already existing `CloudletSchedulerTimeShared` class provides a simplistic implementation that does not take processes priority into account and, in fact, it does not perform a https://en.wikipedia.org/wiki/Preemption_(computing):[preemption process] when there is more process to execute than the number of available CPUs. As an example, consider there are 3 CPU cores and 12 processes to be executed. Such a scheduler will make all these processes to be executed simultaneously, each one using 25% of a CPU core capacity (3 cores / 12 processes), enabling 4 processes to run in each core. 

Even in recent actual processors the presented situation is not possible, since nowadays, technologies such as  http://www.intel.com/content/www/us/en/architecture-and-technology/hyper-threading/hyper-threading-technology.html:[Intel Hyper-Threading (HT)] just enables up to 2 processes running at the same time on each CPU core. In a real scheduler, if there is, for instance, 2 Hyper-Threading CPU cores allocated to 4 processes that are not using the entire cores capacity, a fourth process cannot use this remaining capacity that is in fact wasted, needing to wait one of the processes to be preempted to open room for it to use the CPU. Therefore, the simplistic `CloudletSchedulerTimeShared` can achieve better but inaccurate results.

=== Additional characteristics
Besides all the exclusive features that have been presented, CloudSim Plus additional characteristics that make it a promising cloud simulation framework. Some of them include:

- Completely re-designed and reusable Network module. Totally refactored network examples to make them clear and easy to change.
- Throughout documentation update, improvement and extension.
- Improved class hierarchy, modules and package structure that is easier to understand and follows the https://en.wikipedia.org/wiki/Separation_of_concerns:[Separation of Concerns principle (SoC)]. For instance, power-aware Host classes and interfaces are included into the intuitive https://github.com/manoelcampos/cloudsim-plus/tree/master/cloudsim-plus/src/main/java/org/cloudbus/cloudsim/hosts/power:[org.cloudbus.cloudsim.hosts.power] package, as well as network-enabled ones are included into the https://github.com/manoelcampos/cloudsim-plus/tree/master/cloudsim-plus/src/main/java/org/cloudbus/cloudsim/hosts/network:[org.cloudbus.cloudsim.hosts.network] package. And if you need to find a power or network-enabled Vm, you will intuitively know where to find it.
- As it is usual to extend framework classes to provide some specific behaviors, a researcher will find a totally refactored code that follows clean code programming, https://en.wikipedia.org/wiki/SOLID_(object-oriented_design):[SOLID], https://en.wikipedia.org/wiki/Software_design_pattern:[Design Patterns] and several other software engineering principles and practices. By this way, it will be far easier to understand the code and implement the required feature.
- Integration Tests to increase framework accuracy by testing entire simulation scenarios.
- Updated to Java 8, making extensive use of http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html:[Lambda Expressions] and http://www.oracle.com/technetwork/articles/java/ma14-java-se-8-streams-2177646.html:[Streams API] to improve efficiency and provide a cleaner and easier-to-maintain code.

== Conclusion

== Acknowledge

* CAPES, FCT, IT, UBI, EU/Brazil Cloud Forum.